import random
import logging
import json
import asyncio
import secrets
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from telegram.ext import Application, CommandHandler, CallbackContext, CallbackQueryHandler, MessageHandler, filters

# ... (keep the existing BingoGame class and setup)

class BingoGame:
    def __init__(self):
        # ... (existing initialization)
        self.webapp_url = "https://your-domain.com/webapp.html"  # Update this with your actual URL
        self.user_sessions = {}  # Store user session data for web app

    def generate_webapp_data(self, user_id):
        """Generate data to pre-populate the web app"""
        wallet = self.get_user_wallet(user_id)
        available_cards = sorted(list(self.available_cards))
        
        session_id = secrets.token_hex(16)
        self.user_sessions[session_id] = {
            'user_id': user_id,
            'wallet': wallet,
            'available_cards': available_cards,
            'timestamp': datetime.now(),
            'used': False
        }
        
        return {
            'session_id': session_id,
            'wallet': wallet,
            'stake': self.entry_fee,
            'available_cards': available_cards[:100],  # Send first 100 cards
            'total_cards': len(available_cards),
            'game_active': self.game_active
        }

# Add new web app command handlers
async def webapp_start(update: Update, context: CallbackContext):
    """Start the web app for card selection"""
    user_id = update.effective_user.id
    username = update.effective_user.first_name
    
    if game.game_active:
        await update.message.reply_text("âŒ Game is already in progress! Wait for the next one.")
        return
    
    if user_id in game.players:
        await update.message.reply_text("âœ… You're already in the game!")
        return
    
    # Generate web app data
    webapp_data = game.generate_webapp_data(user_id)
    
    # Create web app button
    keyboard = [
        [InlineKeyboardButton(
            "ğŸ® Open Bingo Card Selector", 
            web_app=WebAppInfo(url=game.webapp_url)
        )]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        f"ğŸ¯ {username}, click the button below to select your bingo card!\n\n"
        f"ğŸ’° Your wallet: {webapp_data['wallet']} coins\n"
        f"ğŸ« Available cards: {webapp_data['total_cards']}\n"
        f"ğŸ† Current pot: {game.pot_amount} coins",
        reply_markup=reply_markup
    )

async def handle_webapp_data(update: Update, context: CallbackContext):
    """Handle data sent from the web app"""
    try:
        if update.effective_message and update.effective_message.web_app_data:
            data = json.loads(update.effective_message.web_app_data.data)
            await process_webapp_selection(update, context, data)
    except Exception as e:
        logger.error(f"Error processing web app data: {e}")
        await update.effective_message.reply_text("âŒ Error processing your selection. Please try again.")

async def process_webapp_selection(update: Update, context: CallbackContext, data: dict):
    """Process card selection from web app"""
    user_id = update.effective_user.id
    username = update.effective_user.first_name
    
    if data.get('action') == 'select_card':
        card_number = data['card_number']
        session_id = data.get('session_id')
        
        # Validate session
        if session_id and session_id in game.user_sessions:
            session = game.user_sessions[session_id]
            if session['user_id'] == user_id and not session['used']:
                # Mark session as used
                game.user_sessions[session_id]['used'] = True
                
                # Process card selection
                await join_with_card(update, context, card_number, user_id, username)
                return
        
        # Fallback: process without session validation
        await join_with_card(update, context, card_number, user_id, username)

# Update the start command to include web app option
async def start(update: Update, context: CallbackContext):
    user = update.effective_user
    
    if game.admin_id is None:
        game.admin_id = user.id
    
    wallet = game.get_user_wallet(user.id)
    
    # Create both web app and quick action buttons
    keyboard = [
        [InlineKeyboardButton(
            "ğŸ® Open Card Selector (Web App)", 
            web_app=WebAppInfo(url=game.webapp_url)
        )],
        [InlineKeyboardButton("ğŸ¯ Quick Join", callback_data="quick_join")],
        [InlineKeyboardButton("ğŸ“Š Statistics", callback_data="stats")],
        [InlineKeyboardButton("ğŸ’° My Wallet", callback_data="wallet")],
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    welcome_text = f"""
ğŸ¯ Welcome to Geez Bingo, {user.first_name}!

ğŸ’° Your Wallet: {wallet} coins
ğŸ« Available Cards: {len(game.available_cards)}
ğŸ† Current Pot: {game.pot_amount}

Click "Open Card Selector" for the best experience!
Or use Quick Join for instant play.

Game Status: {'ğŸŸ¢ ACTIVE' if game.game_active else 'ğŸ”´ INACTIVE'}
    """
    await update.message.reply_text(welcome_text, reply_markup=reply_markup)

# Add web app data handler to main function
def main():
    load_game_state()
    
    application = Application.builder().token("YOUR_BOT_TOKEN_HERE").build()

    # Add command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("webapp", webapp_start))  # New web app command
    application.add_handler(CommandHandler("join", join_command))
    application.add_handler(CommandHandler("card", card_command))
    application.add_handler(CommandHandler("wallet", wallet_command))
    application.add_handler(CommandHandler("status", status_command))
    
    # Add web app data handler
    application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_webapp_data))
    
    # ... (rest of existing handlers)

    print("ğŸ¯ Geez Bingo Bot with Web App is running...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)